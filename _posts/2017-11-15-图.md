---
title: 图
categories:
- 数据结构
tags:
- 图
updated: 2017-11-15
---

- 图：图G由集合V和集合E组成，记为 G＝(V，E)，其中：V是顶点元素的有限集合，E是顶点间关系，有箭头的为*有向图*；

- 图的存储结构

  - 邻接矩阵

    特点：#无向图的邻接矩阵对称

    <img src="{{ site.url }}/assets//blog_images/tu1.png"/>

    ​

  - 邻接表（n由顶点表和边表组成，是链式存储结构）

    <img src="{{ site.url }}/assets//blog_images/tu2.png"/>

    注意：边表顺序是随意的

---

- **DFS**

  从图的某一顶点V出发（起点任选），访问此顶点；然后依次从V的未被访问的邻接点出发，深度优先遍历图，直至图中所有和V相通的顶点都被访问到；若此时图中尚有顶点未被访问，则另选图中一个未被访问的顶点作起点，重复上述过程，直至图中所有顶点都被访问为止。

   <img src="{{ site.url }}/assets//blog_images/tu3.png" width="350px" height="200px"/>

  <img src="{{ site.url }}/assets//blog_images/tu4.png" width="350px" height="200px"/>

- **BFS**

  从图的某一顶点V出发（起点任选），访问顶点；再依次访问V的各个未曾访问过的邻接点；然后分别从这些邻接点出发，依次访问它们的邻接点，并使“先被访问的顶点的邻接点”先于“后被访问的顶点的邻接点”被访问。直至图中所有已被访问的顶点的邻接点都被访问到。若此时图中尚有顶点未被访问，则另选图中一个未被访问的顶点作起点，重复上述过程，直至图中所有顶点都被访问为止。

   <img src="{{ site.url }}/assets//blog_images/tu5.png" width="350px" height="200px"/>

  <img src="{{ site.url }}/assets//blog_images/tu6.png" width="350px" height="200px"/>

  ---

  - 利用图的邻接矩阵来构建、操作图

  ```c++
  #define MAXV 7//最大顶点个数

  typedef int weight;//邻接矩阵元素类型
  typedef char ElemType;//顶点数据元素类型

  //邻接矩阵类型
  typedef struct {
  	weight  arcs[MAXV][MAXV]; //邻接矩阵
  	ElemType  data[MAXV];//一维数组顶点表
  	int n;//顶点个数
  } MGraph, *AdjMatrix;

  //创建邻接矩阵, g是指向图的指针变量，m[][MAXV]是邻接矩阵，d[]是顶点表,n顶点个数
  void CreateGraph(AdjMatrix g, int m[][MAXV], ElemType d[], int n);

  //DFS
  //取顶点v的第一个邻接点
  int GetFirst(AdjMatrix g, int v);

  //取顶点v的位于顶点t之后的下一个邻接点
  int GetNext(AdjMatrix g, int v, int t);

  //以顶点v为起点，深度优先遍历图
  void DFS(AdjMatrix g, int v, int visited[]);
  ```

  <a href="https://github.com/Jackpon/Data-Structures">#具体代码#</a>

- ​